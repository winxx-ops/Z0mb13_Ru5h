<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DEUS EX SOPHIA // STRIKE ELITE</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Consolas', monospace; user-select: none; }
        #hud-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 24px; height: 24px;
            background: transparent; border: 2px solid rgba(0, 255, 0, 0.8); border-radius: 50%;
            transform: translate(-50%, -50%); transition: width 0.1s, height 0.1s;
        }
        #crosshair.dot { width: 4px; height: 4px; background: red; border: none; }
        
        #stats-bar {
            position: absolute; bottom: 30px; left: 30px;
            color: #0f0; font-size: 20px; text-shadow: 0 0 5px #000;
            background: rgba(0,0,0,0.5); padding: 15px; border-left: 4px solid #0f0;
        }
        .stat-row { margin-bottom: 5px; }
        .weapon-icon { display: inline-block; width: 20px; height: 20px; margin-right: 10px; background: #555; }
        
        #weapon-selector {
            position: absolute; top: 30px; right: 30px; text-align: right;
        }
        .w-slot {
            color: #555; font-size: 18px; margin: 5px 0; font-weight: bold; transition: 0.3s;
        }
        .w-slot.active { color: #ff0; text-shadow: 0 0 10px #ff0; font-size: 22px; }

        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; flex-direction: column;
            align-items: center; justify-content: center; color: #fff; pointer-events: auto;
            z-index: 10;
        }
        h1 { font-size: 60px; margin: 0; color: #f00; text-shadow: 0 0 20px #f00; letter-spacing: 5px; }
        p { font-size: 20px; color: #ccc; }
        #start-btn {
            margin-top: 30px; padding: 15px 40px; background: #f00; color: #fff; border: none;
            font-size: 24px; cursor: pointer; text-transform: uppercase; font-weight: bold;
            box-shadow: 0 0 20px #f00; transition: 0.3s;
        }
        #start-btn:hover { background: #fff; color: #f00; }
        
        #ammo-display {
            position: absolute; bottom: 30px; right: 30px;
            font-size: 40px; color: #fff; font-weight: bold;
        }
    </style>
</head>
<body>

<div id="overlay">
    <h1 id="title-text">Z-STRIKE ELITE</h1>
    <p id="sub-text">PROTOCOL: SURVIVAL</p>
    <p id="final-score" style="display:none; color: #ff0; font-size: 30px;"></p>
    <button id="start-btn">INITIALIZE</button>
    <div style="margin-top: 20px; font-size: 14px; color: #666;">
        [WASD] Move | [MOUSE] Aim/Fire | [1-4] Weapons | [SPACE] Jump
    </div>
</div>

<div id="hud-layer">
    <div id="crosshair"></div>
    <div id="stats-bar">
        <div class="stat-row">SCORE: <span id="score">0</span></div>
        <div class="stat-row">THREATS: <span id="zombie-count">0</span></div>
        <div class="stat-row" style="color:red">PROXIMITY ALERT: <span id="prox-count">0</span>/5</div>
    </div>
    <div id="weapon-selector">
        <div class="w-slot active" id="slot-1">[1] GLOCK 17</div>
        <div class="w-slot" id="slot-2">[2] MP5 NAVY</div>
        <div class="w-slot" id="slot-3">[3] AK-47</div>
        <div class="w-slot" id="slot-4">[4] HE GRENADE</div>
    </div>
    <div id="ammo-display">INF</div>
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
import * as THREE from 'three';
import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

// --- CONFIGURATION ---
const CONFIG = {
    spawnRate: 5000,
    maxZombies: 300,
    colors: { sky: 0x050505, fog: 0x050505, ground: 0x111111 },
    weapons: {
        1: { name: 'GLOCK', rate: 200, spread: 0.01, type: 'semi', damage: 35, color: 0x333333 },
        2: { name: 'MP5', rate: 100, spread: 0.04, type: 'auto', damage: 25, color: 0x444455 },
        3: { name: 'AK47', rate: 120, spread: 0.03, type: 'auto', damage: 45, color: 0x8b4513 },
        4: { name: 'GRENADE', rate: 1000, spread: 0, type: 'throw', damage: 200, color: 0x228b22 }
    }
};

// --- GLOBALS ---
let scene, camera, renderer, controls;
let raycaster;
let zombies = [];
let bullets = [];
let grenades = [];
let lastTime = 0;
let score = 0;
let gameState = 'MENU'; // MENU, PLAYING, GAMEOVER
let currentWeapon = 1;
let lastFireTime = 0;
let isFiring = false;

// Movement
const velocity = new THREE.Vector3();
const direction = new THREE.Vector3();
let moveFwd = false, moveBwd = false, moveLeft = false, moveRight = false, canJump = false;

// Weapon Models
let weaponGroup;
const gunModels = {};

// DOM Elements
const ui = {
    score: document.getElementById('score'),
    zCount: document.getElementById('zombie-count'),
    prox: document.getElementById('prox-count'),
    slots: [
        document.getElementById('slot-1'),
        document.getElementById('slot-2'),
        document.getElementById('slot-3'),
        document.getElementById('slot-4')
    ],
    overlay: document.getElementById('overlay'),
    title: document.getElementById('title-text'),
    sub: document.getElementById('sub-text'),
    btn: document.getElementById('start-btn'),
    finalScore: document.getElementById('final-score')
};

init();

function init() {
    // SCENE
    scene = new THREE.Scene();
    scene.background = new THREE.Color(CONFIG.colors.sky);
    scene.fog = new THREE.FogExp2(CONFIG.colors.fog, 0.03);

    // CAMERA
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.y = 1.7;

    // RENDERER
    renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // LIGHTS
    const ambLight = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambLight);
    
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(10, 20, 10);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    scene.add(dirLight);

    // FLOOR
    const floorGeo = new THREE.PlaneGeometry(300, 300);
    const floorMat = new THREE.MeshStandardMaterial({ 
        color: CONFIG.colors.ground, roughness: 0.9, metalness: 0.1 
    });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // WEAPON MODELS (Procedural)
    weaponGroup = new THREE.Group();
    camera.add(weaponGroup);
    
    // Glock
    const glock = new THREE.Group();
    const gBody = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, 0.2), new THREE.MeshStandardMaterial({color:0x222222}));
    const gHandle = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.1, 0.05), new THREE.MeshStandardMaterial({color:0x111111}));
    gHandle.position.set(0, -0.05, 0.05);
    gHandle.rotation.x = 0.2;
    glock.add(gBody, gHandle);
    glock.position.set(0.2, -0.2, -0.4);
    glock.visible = true;
    gunModels[1] = glock;
    weaponGroup.add(glock);

    // MP5
    const mp5 = new THREE.Group();
    const mBody = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.08, 0.4), new THREE.MeshStandardMaterial({color:0x333333}));
    const mMag = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.15, 0.05), new THREE.MeshStandardMaterial({color:0x111111}));
    mMag.position.set(0, -0.1, 0.05);
    mp5.add(mBody, mMag);
    mp5.position.set(0.25, -0.25, -0.5);
    mp5.visible = false;
    gunModels[2] = mp5;
    weaponGroup.add(mp5);

    // AK47
    const ak = new THREE.Group();
    const aBody = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.06, 0.6), new THREE.MeshStandardMaterial({color:0x111111}));
    const aStock = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.1, 0.2), new THREE.MeshStandardMaterial({color:0x8b4513}));
    aStock.position.set(0, -0.05, 0.3);
    const aMag = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.2, 0.1), new THREE.MeshStandardMaterial({color:0x222222}));
    aMag.position.set(0, -0.1, 0);
    aMag.rotation.x = 0.3;
    ak.add(aBody, aStock, aMag);
    ak.position.set(0.25, -0.25, -0.6);
    ak.visible = false;
    gunModels[3] = ak;
    weaponGroup.add(ak);

    // Grenade Hand
    const nade = new THREE.Group();
    const nBody = new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 8), new THREE.MeshStandardMaterial({color:0x228b22}));
    nade.add(nBody);
    nade.position.set(0.2, -0.2, -0.3);
    nade.visible = false;
    gunModels[4] = nade;
    weaponGroup.add(nade);

    scene.add(camera);

    // CONTROLS
    controls = new PointerLockControls(camera, document.body);
    raycaster = new THREE.Raycaster();

    // EVENTS
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    document.addEventListener('mousedown', () => isFiring = true);
    document.addEventListener('mouseup', () => isFiring = false);
    window.addEventListener('resize', onResize);
    ui.btn.addEventListener('click', startGame);

    requestAnimationFrame(animate);
}

function startGame() {
    controls.lock();
    ui.overlay.style.display = 'none';
    gameState = 'PLAYING';
    
    // Reset
    zombies.forEach(z => scene.remove(z.mesh));
    zombies = [];
    score = 0;
    ui.score.innerText = '0';
    ui.finalScore.style.display = 'none';

    // Spawn Initial Wave (More than 5)
    for(let i=0; i<8; i++) spawnZombie();

    // Spawn Loop
    setInterval(() => {
        if(gameState !== 'PLAYING') return;
        // Double logic with cap
        const count = zombies.length;
        if(count > 0 && count < CONFIG.maxZombies) {
            const toAdd = Math.min(count, CONFIG.maxZombies - count);
            for(let i=0; i<toAdd; i++) spawnZombie();
        } else if (count === 0) {
            spawnZombie();
        }
    }, CONFIG.spawnRate);
}

function spawnZombie() {
    const angle = Math.random() * Math.PI * 2;
    const dist = 20 + Math.random() * 30; // Spawn further away
    const x = Math.sin(angle) * dist;
    const z = Math.cos(angle) * dist;

    const group = new THREE.Group();
    group.position.set(x, 0, z);

    // Green Body
    const bodyGeo = new THREE.BoxGeometry(0.8, 1.4, 0.5);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2e8b57 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.7;
    body.castShadow = true;
    body.userData = { type: 'body', parent: group };

    // Red Head
    const headGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
    const headMat = new THREE.MeshStandardMaterial({ color: 0x8b0000 });
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.y = 1.6;
    head.castShadow = true;
    head.userData = { type: 'head', parent: group };

    group.add(body, head);
    scene.add(group);
    
    // Assign random speed
    const speed = 2 + Math.random() * 3;
    
    zombies.push({ mesh: group, hp: 100, speed: speed, id: Math.random() });
}

function onKeyDown(e) {
    switch(e.code) {
        case 'KeyW': moveFwd = true; break;
        case 'KeyS': moveBwd = true; break;
        case 'KeyA': moveLeft = true; break;
        case 'KeyD': moveRight = true; break;
        case 'Space': if(canJump) velocity.y += 15; canJump = false; break;
        case 'Digit1': switchWeapon(1); break;
        case 'Digit2': switchWeapon(2); break;
        case 'Digit3': switchWeapon(3); break;
        case 'Digit4': switchWeapon(4); break;
    }
}

function onKeyUp(e) {
    switch(e.code) {
        case 'KeyW': moveFwd = false; break;
        case 'KeyS': moveBwd = false; break;
        case 'KeyA': moveLeft = false; break;
        case 'KeyD': moveRight = false; break;
    }
}

function switchWeapon(id) {
    currentWeapon = id;
    Object.values(gunModels).forEach(m => m.visible = false);
    gunModels[id].visible = true;
    
    ui.slots.forEach((el, idx) => {
        el.classList.remove('active');
        if(idx + 1 === id) el.classList.add('active');
    });
}

function fireWeapon(time) {
    const w = CONFIG.weapons[currentWeapon];
    if (time - lastFireTime < w.rate) return;
    lastFireTime = time;

    // Recoil Animation
    const gun = gunModels[currentWeapon];
    gun.position.z += 0.1; 
    setTimeout(() => gun.position.z -= 0.1, 50);

    if (currentWeapon === 4) {
        throwGrenade();
        return;
    }

    // Hitscan
    raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
    
    // Spread
    raycaster.ray.direction.x += (Math.random()-0.5) * w.spread;
    raycaster.ray.direction.y += (Math.random()-0.5) * w.spread;

    // Get intersectable objects
    const targets = [];
    zombies.forEach(z => z.mesh.children.forEach(c => targets.push(c)));

    const intersects = raycaster.intersectObjects(targets);

    // Muzzle Flash
    const flash = new THREE.PointLight(0xffff00, 1, 3);
    flash.position.set(0.2, -0.2, -1);
    camera.add(flash);
    setTimeout(() => camera.remove(flash), 50);

    if (intersects.length > 0) {
        const hit = intersects[0];
        const part = hit.object.userData.type;
        const parent = hit.object.userData.parent;
        const zObj = zombies.find(z => z.mesh === parent);

        if (zObj) {
            // Visual Blood
            createParticles(hit.point, 0xff0000, 5);

            if (part === 'head') {
                killZombie(zObj, true);
            } else {
                zObj.hp -= w.damage;
                if (zObj.hp <= 0) killZombie(zObj, false);
                
                // Knockback
                const dir = new THREE.Vector3().subVectors(zObj.mesh.position, camera.position).normalize();
                zObj.mesh.position.add(dir.multiplyScalar(0.5));
            }
        }
    }
}

function throwGrenade() {
    const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({color:0x00ff00}));
    sphere.position.copy(camera.position);
    sphere.position.y -= 0.5; // Throw from hand
    
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    
    const vel = dir.multiplyScalar(15);
    vel.y += 5; // Arc

    scene.add(sphere);
    grenades.push({ mesh: sphere, vel: vel, life: 2000 });
}

function createParticles(pos, color, count) {
    const geo = new THREE.BufferGeometry();
    const posArr = [];
    for(let i=0; i<count; i++) {
        posArr.push(pos.x + (Math.random()-0.5), pos.y + (Math.random()-0.5), pos.z + (Math.random()-0.5));
    }
    geo.setAttribute('position', new THREE.Float32BufferAttribute(posArr, 3));
    const mat = new THREE.PointsMaterial({ color: color, size: 0.1 });
    const sys = new THREE.Points(geo, mat);
    scene.add(sys);
    setTimeout(() => scene.remove(sys), 500);
}

function killZombie(zObj, isHeadshot) {
    scene.remove(zObj.mesh);
    zombies = zombies.filter(z => z !== zObj);
    score += isHeadshot ? 100 : 50;
    ui.score.innerText = score;
}

function gameOver() {
    gameState = 'GAMEOVER';
    controls.unlock();
    ui.overlay.style.display = 'flex';
    ui.title.innerText = "KIA";
    ui.sub.innerText = "POSITION OVERRUN";
    ui.btn.innerText = "RE-DEPLOY";
    ui.finalScore.innerText = "FINAL SCORE: " + score;
    ui.finalScore.style.display = 'block';
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate(time) {
    requestAnimationFrame(animate);
    const dt = (time - lastTime) / 1000;
    lastTime = time;

    if (gameState === 'PLAYING') {
        if (controls.isLocked) {
            // PLAYER MOVEMENT
            velocity.x -= velocity.x * 10.0 * dt;
            velocity.z -= velocity.z * 10.0 * dt;
            velocity.y -= 9.8 * 20.0 * dt; 

            direction.z = Number(moveFwd) - Number(moveBwd);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            if (moveFwd || moveBwd) velocity.z -= direction.z * 100.0 * dt;
            if (moveLeft || moveRight) velocity.x -= direction.x * 100.0 * dt;

            controls.moveRight(-velocity.x * dt);
            controls.moveForward(-velocity.z * dt);
            controls.getObject().position.y += (velocity.y * dt);

            if (controls.getObject().position.y < 1.7) {
                velocity.y = 0;
                controls.getObject().position.y = 1.7;
                canJump = true;
            }

            // WEAPON FIRING
            if (isFiring && currentWeapon !== 4) { // Grenade throws once
                fireWeapon(time);
            } else if (isFiring && currentWeapon === 4 && time - lastFireTime > 1000) {
                fireWeapon(time);
            }

            // GRENADE PHYSICS
            grenades.forEach((g, i) => {
                g.mesh.position.add(g.vel.clone().multiplyScalar(dt));
                g.vel.y -= 20 * dt; // Gravity
                
                // Floor bounce
                if (g.mesh.position.y < 0.2) {
                    g.vel.y *= -0.5;
                    g.vel.x *= 0.5;
                    g.vel.z *= 0.5;
                    g.mesh.position.y = 0.2;
                }
                
                g.life -= dt * 1000;
                if (g.life <= 0) {
                    // Explode
                    createParticles(g.mesh.position, 0xffaa00, 20);
                    // Area Damage
                    zombies.forEach(z => {
                        if (z.mesh.position.distanceTo(g.mesh.position) < 8) {
                            killZombie(z, false);
                        }
                    });
                    scene.remove(g.mesh);
                    grenades.splice(i, 1);
                }
            });

            // ZOMBIE AI & GAME OVER CHECK
            let closeZombies = 0;
            const playerPos = controls.getObject().position;

            zombies.forEach(z => {
                const dist = z.mesh.position.distanceTo(playerPos);
                
                // Move logic
                const dir = new THREE.Vector3().subVectors(playerPos, z.mesh.position).normalize();
                z.mesh.position.add(dir.multiplyScalar(z.speed * dt));
                z.mesh.lookAt(playerPos.x, 1, playerPos.z);
                
                // Count close enemies (Attack Range)
                if (dist < 2.0) {
                    closeZombies++;
                }
            });

            ui.zCount.innerText = zombies.length;
            ui.prox.innerText = closeZombies;

            if (closeZombies >= 5) {
                gameOver();
            }
        }
    }

    renderer.render(scene, camera);
}
</script>
</body>
</html>
